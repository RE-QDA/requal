<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>requal – reproducibility-enhancing-modules</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../img/rql_logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">requal</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../get_started.html" rel="" target="">
 <span class="menu-text">Getting started</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../contact.html" rel="" target="">
 <span class="menu-text">Contact</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../wiki.html" rel="" target="">
 <span class="menu-text">Wiki</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/RE-QDA/requal" rel="" target="_blank"><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#agreement" id="toc-agreement" class="nav-link" data-scroll-target="#agreement">Agreement</a>
  <ul class="collapse">
  <li><a href="#total-overlap-character" id="toc-total-overlap-character" class="nav-link" data-scroll-target="#total-overlap-character">Total overlap [character]</a></li>
  <li><a href="#overlap-by-code-character" id="toc-overlap-by-code-character" class="nav-link" data-scroll-target="#overlap-by-code-character">Overlap by code [character]</a></li>
  <li><a href="#overlap-by-coder-character" id="toc-overlap-by-coder-character" class="nav-link" data-scroll-target="#overlap-by-coder-character">Overlap by coder [character]</a></li>
  <li><a href="#overlap-by-coder-and-code-character" id="toc-overlap-by-coder-and-code-character" class="nav-link" data-scroll-target="#overlap-by-coder-and-code-character">Overlap by coder and code [character]</a></li>
  <li><a href="#overlap-by-user-attribute-and-code-character" id="toc-overlap-by-user-attribute-and-code-character" class="nav-link" data-scroll-target="#overlap-by-user-attribute-and-code-character">Overlap by user attribute and code [character]</a></li>
  <li><a href="#segment-matching" id="toc-segment-matching" class="nav-link" data-scroll-target="#segment-matching">Segment matching</a></li>
  </ul></li>
  <li><a href="#text-overlap" id="toc-text-overlap" class="nav-link" data-scroll-target="#text-overlap">Text overlap</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<p>On the <code>Report</code> page you will find several modules to increase researcher reflexivity and coding transparency. These modules only work in the web version of reQual, as it allows coding by multiple coders and comparison between them.</p>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>The first tab <code>Summary</code> provides an overview of the number of segments tagged by each code in each document. If we want to know how often and where a particular coder used the codes, we only select her in the <code>Select users</code> menu. Similarly, we can limit the selection to only certain codes or documents if there are many of them and the overall table is too large.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/RE-QDA/requal/assets/54745940/aa384d03-72ed-440c-8d8d-c33e869d23aa.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">image</figcaption>
</figure>
</div>
</section>
<section id="agreement" class="level2">
<h2 class="anchored" data-anchor-id="agreement">Agreement</h2>
<p>The <code>Agreement</code> tab offers the possibility to make the agreement between codes, coders and their attributes visible. When we expand the <code>Select metrics</code> menu, we see two sets of controls to choose from. The first one shows the agreement calculated based on the number of overlapping letters (characters), the second one shows the agreement based on the overlap of the marked segments regardless of the number of characters (segment). The calculation is done using <a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard’s similarity coefficient</a>, which is calculated as the ratio of the number of identically coded characters to the number of all coded characters without the overlaps.</p>
<p>We can illustrate the difference between agreement in characters and agreement in segments by an example:</p>
<ul>
<li>Coder A marks: But it’s just me, the problem with me is that I don’t drink beer, I don’t like it (55 characters).<br>
</li>
<li>Coder B marks: But just me, the problem with me is that I don’t drink beer, I don’t like it. I’m not an alcoholic. (71 characters)</li>
</ul>
<p>The character agreement will be 0.77 according to the calculation 55/(55+71-55) = 0.77<br>
The agreement in segments will be 1.00 according to the calculation 1/(1+1-1) = 1.00</p>
<ul>
<li>Coder A indicates: But just me, the problem with me is that I don’t drink beer, I don’t like it. (55 characters)<br>
</li>
<li>Coder B indicates: But it’s just me, the problem with me is that I don’t drink beer, (…) I’m not an alcoholic. (43 + 16 = 59 characters)</li>
</ul>
<p>The agreement in characters will be 0.77 according to the calculation 43/(55+59-43) = 0.61<br>
The match in segments will be 1.00 based on the calculation 1/(1+2-1) = 0.50</p>
<p>From these examples we can see that each criterion is sensitive to different coding qualities. While the number of common characters is more of a mechanical measure of agreement, the agreement in segments is more reflective of the meaning component of coding the data.</p>
<section id="total-overlap-character" class="level3">
<h3 class="anchored" data-anchor-id="total-overlap-character">Total overlap [character]</h3>
<p>Calculates the total coding overlap in characters across all documents for the selected coders. This table provides an overview of the total overlap of coders in the project.</p>
</section>
<section id="overlap-by-code-character" class="level3">
<h3 class="anchored" data-anchor-id="overlap-by-code-character">Overlap by code [character]</h3>
<p>Calculates the coding agreement in characters across all documents for each code and for the selected coders. This table provides an overview of whether the overlap varies by code. It allows the identification of problematic codes.</p>
</section>
<section id="overlap-by-coder-character" class="level3">
<h3 class="anchored" data-anchor-id="overlap-by-coder-character">Overlap by coder [character]</h3>
<p>Displays a heatmap that compares pairs of coders based on their character agreement across all documents and all codes. The lighter the color, the higher the agreement. This table allows identification of pairs of coders that are ” aligned” overall, and those that are least aligned.</p>
</section>
<section id="overlap-by-coder-and-code-character" class="level3">
<h3 class="anchored" data-anchor-id="overlap-by-coder-and-code-character">Overlap by coder and code [character]</h3>
<p>Displays a heatmap for each code separately, comparing pairs of coders based on their agreement in characters across all documents. The lighter the color, the higher the agreement. This table allows you to see if the coder pair matching is similar across all codes, or if and how the matching differs for different codes.</p>
</section>
<section id="overlap-by-user-attribute-and-code-character" class="level3">
<h3 class="anchored" data-anchor-id="overlap-by-user-attribute-and-code-character">Overlap by user attribute and code [character]</h3>
<p>Displays a heatmap for the selected user (encoder) attribute that compares each group of coders based on their agreement in characters for each code in all documents. The lighter the color, the higher the agreement. This table may reveal codes that are sensitive to any of the coders’ attributes. For example, in the diagram we see that for code 2, there are more matches between males and females than between males, which shows that the gender of the coders does not play a role in this code.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/RE-QDA/requal/assets/54745940/902e2fd9-b033-4d44-b6ba-18ab475bbcb0.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">image</figcaption>
</figure>
</div>
</section>
<section id="segment-matching" class="level3">
<h3 class="anchored" data-anchor-id="segment-matching">Segment matching</h3>
<p>The same set of indicators exists for agreement in segments. Their interpretation is the same, with the only difference that matching is not counted in identically coded characters, but in overlapping segments.</p>
</section>
</section>
<section id="text-overlap" class="level2">
<h2 class="anchored" data-anchor-id="text-overlap">Text overlap</h2>
<p>If we want to examine the coding agreement in more detail, we use the <code>Text overlap</code> tab. In the menu, we select which document we want to display, which code, and possibly certain coders, if we want information about, for example, a two-coder agreement.</p>
<p>Clicking the <code>Browse</code> button will show us the coders overlaps for the given code and document. The lighter the color, the higher the agreement between the coders.</p>
<p>When we hover the mouse over a highlighted segment, the names of the coders who coded it are displayed. This provides a good basis for a team discussion about coding. For example, about how long segments to code or how distinct instances of a phenomenon to code.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://github.com/RE-QDA/requal/assets/54745940/45c1f4bb-d4d9-4984-940c-d5effd7b90a9.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">image</figcaption>
</figure>
</div>
<p>Tip! This module can also be used to allow users with permissions to view the report to see how individual coders coded, e.g.&nbsp;in a class project.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>